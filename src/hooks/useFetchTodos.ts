// Utils
import { Todo } from '@/store/todo'
import { useState } from 'react'
import { useToast } from './useToast'

// Вынес за пределы хука, чтобы не объявлялась по несколько раз при ререндерах хука
// Лимит всегда один, поэтому в данном случае мы можем это сделать
const limit = 20

// Хук для получения задач
export const useFetchTodos = () => {
	// Состояния загрузки задач
	const [isLoading, setIsLoading] = useState(false)

	// Состояние для индекса задачи с которого будут приходить задачи (в нашем случае это диапозон от startIdx до limit)
	const [startIdx, setStartIdx] = useState(0)

	// Общее количество задач, которые мы можем запросить
	const [totalCount, setTotalCount] = useState(0)

	// Тостер для уведомлений об успехе/не успехе операции для пользователя
	const { toast } = useToast()

	// Снова возвращаем значения с фиксированым неймингом, чтобы редактор кода лучше подхватывал значения, для приведения
	// к общему стилю участков проекта, где используется хук и чтобы была возможность пропускать значения, которые мы не хотил получать,
	// прим. если бы мы вернули массив, то не смогли бы получить fetchTodos, не указав название переменной для setIsLoading, была бы
	// такая контрукция [isLoading, _, fetchTodos] = ...
	// Точнее будет сказать, что могли бы, но это будет более громоздко, прим.
	// const fetchedTodos = useHook()
	// const isLoading = fetchedTodos[0]
	// const fetchTodos = fetchedTodos[2]
	return {
		isLoading,
		setIsLoading,
		fetchTodos: async function () {
			try {
				// Меняем состояние загрузки данных
				setIsLoading(true)

				// Если мы достигли придела в количестве задач и если это не первый запрос на получение задач
				if (startIdx >= totalCount && startIdx !== 0) {
					// Прерываем выполнение функции
					return
				}

				// Кидаем запрос на получение задач
				const res = await Todo.fetchTodos(startIdx, limit)

				// Получаем из заголовков общее количество доступнух задач
				const count = res?.headers['x-total-count']

				// Если максимального значения нет в стейте и если мы получили это число от апи
				if (totalCount === 0 && !!count) {
					// Помещаем это число в стейт
					setTotalCount(count)
				}

				// Если массив пустой
				if (!res?.data?.length) {
					// Уведомляем пользователя, что не смогли получить задачи
					toast({
						title: 'Ошибка',
						description: 'Не удалось получить список задач',
						variant: 'destructive',
					})

					// Прерываем выполнение функции
					return
				}

				// Новый список
				let newList = []

				// При повторных рендерах (было видно в дев режиме) конструкция [...Todo.list, ...res.data] создавала дублирующиеся объекты,
				// поэтому при добавлении новой пачки с задачами, мы проверяем не являются ли они дубликатами
				// Проверив любой объект на наличие в уже имеющемся массиве, мы делаем вывод, что пришедший массив не имеет дубликатов т.к
				// стартовый индекс с которого мы начинаем получать задачи, при каждом успешном запросе другой и не пересекаются
				const foundIdx = Todo.list.findIndex(todo => todo.id === res.data[0].id)

				// Если не нашли дубликатов
				if (foundIdx === -1) {
					// Разворачиваем в новый массив старый + новый список
					newList = [...Todo.list, ...res.data]
				} else {
					// Если индекс все же найден, значит это был двойной рендер и пришедший список задач, у нас, первый
					newList = res.data
				}

				// Меняем список задач в сторе
				Todo.setList(newList)

				// Увеличиваем
				setStartIdx(startIdx + limit)
			} catch (e) {
				// Показываем ошибку в консоли
				console.log(e)

				// Уведомляем пользователя, что не смогли получить задачи
				toast({
					title: 'Ошибка',
					description: 'Не удалось получить список задач',
					variant: 'destructive',
				})
			} finally {
				setIsLoading(false)
			}
		},
	}
}
